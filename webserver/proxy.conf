  # keys_zone=mycache:10m. Defines name of the cache and memory space (keys, metadata information
  proxy_cache_path /var/cache/nginx/mycache levels=1:2 keys_zone=mycache:10m;

  server {
    server_name webapp.me*; # file /etc/hosts modified
    listen 8080  default_server;

    set $upstream $PROXY_UPSTREAM;
    
    # configure a resolver for Nginx with the address of your actual DNS resolver.
    # docker-compose exec webserver cat /etc/resolv.conf -> nameserver 127.0.0.11
    resolver 127.0.0.11:53  valid=1s; # <- needs a network !!, so ok in docker-compose !!
        
    # proxy_cache_key $scheme$request_method$host$request_uri;
    # This needs to be unique for each cached requests and used to generate the cache file names.

    location ~ \.(jpeg|css|png|js|webp)$ {

      root /usr/share/nginx/html; 
      # return 301 http://webapp:8080$uri;

      gzip_static on;
      access_log off;
      # expires max;
      # add_header Cache-Control public;     
      # add_header Last-Modified "";    
      # add_header ETag "";

      # -Proxy-
      add_header  X-Cache $upstream_cache_status; ## VU MAIS MISS ##
      proxy_cache mycache;
      proxy_cache_valid 60m;
      break;  
    }

    location / {
      try_files $uri @app;
    }

    location @app {      
      proxy_pass http://$upstream$request_uri;

      proxy_pass_header Authorization;

      proxy_http_version 1.1;
      proxy_ssl_server_name on;
      
      proxy_set_header Host $upstream;
      # $http_host needed for Rails ??
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;      
      
      add_header X-Proxy-Cache $upstream_cache_status; ## VU MAIS MISS ##

      proxy_buffering off;
      proxy_read_timeout 5s;
      proxy_redirect off;
      proxy_ssl_verify off;
      client_max_body_size 0;
    }
  }
